<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TidalTeensy Code Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', 'Consolas', monospace;
            background: #0a0e27;
            color: #00ff00;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        /* Connection Modal */
        #connectionModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        #connectionModal.hidden {
            display: none;
        }
        
        .modal-content {
            background: #16213e;
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
        }
        
        .modal-content h2 {
            color: #00ff88;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        .modal-content p {
            color: #aaa;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        button {
            background: #00ff88;
            color: #0a0e27;
            border: none;
            padding: 12px 30px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00ffff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
        }
        
        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Terminal Header */
        .terminal-header {
            background: #16213e;
            border-bottom: 2px solid #00ff88;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .terminal-title {
            color: #00ff88;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .terminal-status {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
            font-size: 0.9em;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: #00ff88;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 0;
            overflow: hidden;
            min-height: 0; /* Important for flex children */
        }
        
        /* Code Editor Panel */
        .editor-panel {
            display: flex;
            flex-direction: column;
            border-right: 2px solid #00ff88;
            background: #0a0e27;
            min-height: 0; /* Important for flex scrolling */
            overflow: hidden;
        }
        
        .editor-header {
            background: #16213e;
            border-bottom: 1px solid #00ff88;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .editor-title {
            color: #00ff88;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .editor-actions {
            display: flex;
            gap: 8px;
        }
        
        .btn-editor {
            background: #00ff88;
            color: #0a0e27;
            border: none;
            padding: 5px 12px;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .btn-editor:hover {
            background: #00ffff;
            transform: translateY(-1px);
        }
        
        .btn-editor.danger {
            background: #ff4444;
            color: white;
        }
        
        .btn-editor.danger:hover {
            background: #ff6666;
        }
        
        /* Code Editor Area */
        .code-editor-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }
        
        .line-numbers {
            background: #16213e;
            color: #666;
            padding: 15px 10px;
            text-align: right;
            user-select: none;
            font-size: 14px;
            line-height: 1.6;
            border-right: 1px solid #00ff88;
            min-width: 50px;
            overflow: hidden;
        }
        
        .line-numbers div {
            padding: 0 5px;
        }
        
        .line-numbers div.active {
            background: #00ff8820;
            color: #00ff88;
            font-weight: bold;
        }
        
        .line-numbers div.modified {
            color: #ffaa00;
        }
        
        .line-numbers div.error {
            color: #ff4444;
        }
        
        #codeEditor {
            flex: 1;
            background: #0a0e27;
            color: #00ff00;
            border: none;
            padding: 15px;
            font-family: 'Courier New', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            overflow-y: auto;
            white-space: pre;
            overflow-wrap: normal;
        }
        
        #codeEditor::-webkit-scrollbar {
            width: 10px;
        }
        
        #codeEditor::-webkit-scrollbar-track {
            background: #0a0e27;
        }
        
        #codeEditor::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 5px;
        }
        
        /* Console Panel */
        .console-panel {
            display: flex;
            flex-direction: column;
            background: #0a0e27;
            position: relative; /* Pour le positionnement du bouton scroll */
            min-height: 0; /* Important for flex scrolling */
            overflow: hidden; /* Contient les enfants */
        }
        
        .console-header {
            background: #16213e;
            border-bottom: 1px solid #00ff88;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .console-title {
            color: #00ff88;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .console-output {
            flex: 1;
            padding: 15px;
            overflow-y: scroll; /* Force scroll bar */
            overflow-x: hidden;
            font-size: 13px;
            line-height: 1.5;
            min-height: 0; /* Important for flex scrolling */
        }
        
        .console-output::-webkit-scrollbar {
            width: 8px;
        }
        
        .console-output::-webkit-scrollbar-track {
            background: #0a0e27;
        }
        
        .console-output::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 5px;
        }
        
        .console-line {
            margin-bottom: 3px;
            word-wrap: break-word;
        }
        
        .console-line.prompt {
            color: #00ff88;
        }
        
        .console-line.error {
            color: #ff4444;
        }
        
        .console-line.success {
            color: #00ffff;
        }
        
        .console-line.info {
            color: #ffaa00;
        }
        
        .console-line.teensy {
            color: #00ff00;
        }
        
        .console-line.parsed {
            color: #888;
            font-style: italic;
        }
        
        /* Scroll to bottom button */
        #scrollToBottomBtn {
            position: absolute;
            bottom: 70px;
            right: 20px;
            background: #00ff88;
            color: #0a0e27;
            border: none;
            padding: 8px 16px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.4);
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            display: none; /* Cach√© par d√©faut */
            z-index: 100;
        }
        
        #scrollToBottomBtn:hover {
            background: #00ffff;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 255, 136, 0.6);
        }
        
        #scrollToBottomBtn.visible {
            display: block;
        }
        
        /* Visualizer Panel */
        .visualizer-panel {
            background: #0f1419;
            border: 1px solid #00ff88;
            border-radius: 5px;
            margin: 15px;
            overflow: hidden;
            transition: all 0.3s ease;
            display: none;
        }
        
        .visualizer-panel.visible {
            display: block;
        }
        
        .visualizer-header {
            background: #16213e;
            padding: 10px 15px;
            border-bottom: 1px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .visualizer-title {
            color: #00ff88;
            font-size: 1em;
            font-weight: bold;
        }
        
        .visualizer-content {
            padding: 15px;
            height: 320px;
            overflow-y: auto;
        }
        
        .channel-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 10px;
        }
        
        .channel-label {
            color: #00ff88;
            font-weight: bold;
            width: 30px;
            text-align: right;
            font-size: 0.9em;
        }
        
        .channel-timeline {
            flex: 1;
            height: 30px;
            background: #1a1f2e;
            border: 1px solid #2a3f5f;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .timeline-pattern {
            color: #888;
            font-size: 0.75em;
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 90%;
        }
        
        .event-box {
            position: absolute;
            top: 3px;
            bottom: 3px;
            background: linear-gradient(180deg, #00ff88, #007f44);
            border-radius: 4px;
            opacity: 0.95;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #04121a;
            font-size: 0.7em;
            text-align: center;
            padding: 0 4px;
            box-sizing: border-box;
            transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.12s ease;
            white-space: nowrap;
        }

        .event-box[data-label]::after {
            content: attr(data-label);
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            pointer-events: none;
        }

        .event-box.active {
            background: linear-gradient(180deg, #ffff66, #ffcc00);
            box-shadow: 0 4px 12px rgba(255,204,0,0.6);
            transform: translateY(-1px) scale(1.02);
            color: #0a0e27;
            z-index: 5;
        }
        
        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff4444;
            box-shadow: 0 0 5px #ff4444;
            z-index: 10;
            transition: left 0.1s linear;
        }
        
        /* Quick Commands */
        .quick-commands {
            background: #16213e;
            padding: 10px 15px;
            border-top: 1px solid #00ff88;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .quick-commands-label {
            color: #888;
            font-size: 11px;
        }
        
        .quick-btn {
            background: #0a0e27;
            color: #00ff88;
            border: 1px solid #00ff88;
            padding: 4px 10px;
            font-size: 10px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Courier New', monospace;
        }
        
        .quick-btn:hover {
            background: #00ff88;
            color: #0a0e27;
        }
        
        /* Syntax Highlighting (simple) */
        .syntax-channel { color: #00ffff; }
        .syntax-sample { color: #ffaa00; }
        .syntax-note { color: #ff88ff; }
        .syntax-command { color: #00ff88; }
        .syntax-number { color: #ff8800; }
        .syntax-operator { color: #888; }
    </style>
</head>
<body>
    <!-- Connection Modal -->
    <div id="connectionModal">
        <div class="modal-content">
            <h2> TidalTeensy Code Editor</h2>
            <p>Interface de live coding multi-lignes pour Teensy 4.0</p>
            <p style="font-size: 0.9em; color: #ff8800;">
                 N√©cessite Chrome, Edge ou Opera<br>
                (Web Serial API)
            </p>
            <div class="modal-buttons">
                <button onclick="connectSerial()"> Se connecter au Teensy</button>
            </div>
            <p style="margin-top: 20px; font-size: 0.85em; color: #666;">
                Le navigateur va vous demander de s√©lectionner le port s√©rie USB
            </p>
        </div>
    </div>

    <!-- Terminal Header -->
    <div class="terminal-header">
        <div class="terminal-title">TidalTeensy Code Editor</div>
        <div class="terminal-status">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">D√©connect√©</span>
            </div>
            <button class="btn-small" onclick="toggleVisualizer()" id="visualizerToggle"> Afficher Visualiseur</button>
            <button class="btn-small" onclick="toggleConnection()">D√©connecter</button>
        </div>
    </div>

    <!-- Main Content: Editor + Console -->
    <div class="main-content">
        <!-- Code Editor Panel -->
        <div class="editor-panel">
            <div class="editor-header">
                <div class="editor-title"> Code Editor</div>
                <div class="editor-actions">
                    <button class="btn-editor" onclick="evaluateCode()" title="Ctrl+Enter">‚ñ∂ Evaluate All</button>
                    <button class="btn-editor" onclick="evaluateSelection()" title="Shift+Enter">‚ñ∂ Eval Line</button>
                    <button class="btn-editor danger" onclick="clearAllPatterns()" title="Ctrl+.">‚ñ† Stop All</button>
                </div>
            </div>
            
            <div class="code-editor-wrapper">
                <div class="line-numbers" id="lineNumbers"></div>
                <textarea id="codeEditor" spellcheck="false" placeholder="-- √âcrivez votre code TidalTeensy ici
-- Exemples:
d1 bd sd hh cp
d2 bd*4
d3 hh*8
d4 sine:c4 sine:e4 sine:g4

-- Commandes:
bpm 140
clear

-- Ctrl+Enter: √âvaluer tout
-- Shift+Enter: √âvaluer la ligne courante
-- Ctrl+.: Stop tous les patterns"></textarea>
            </div>
        </div>
        
        <!-- Console Panel -->
        <div class="console-panel">
            <div class="console-header">
                <div class="console-title">Console</div>
                <div class="editor-actions">
                    <button class="btn-editor" onclick="clearConsole()">Clear</button>
                </div>
            </div>
            
            <div class="console-output" id="consoleOutput">
                <div class="console-line info">TidalTeensy Code Editor v1.0</div>
                <div class="console-line">En attente de connexion...</div>
            </div>
            
            <!-- Scroll to bottom button (appears when scrolled up) -->
            <button id="scrollToBottomBtn" onclick="scrollToBottom()"> Nouveaux messages</button>
            
            <!-- Quick Commands Bar -->
            <div class="quick-commands">
                <span class="quick-commands-label">Quick:</span>
                <button class="quick-btn" onclick="insertCode('d1 bd sd hh cp')">d1 drums</button>
                <button class="quick-btn" onclick="insertCode('d2 bass:c2*4')">d2 bass</button>
                <button class="quick-btn" onclick="insertCode('d3 sine:c4 sine:e4 sine:g4')">d3 chord</button>
                <button class="quick-btn" onclick="insertCode('bpm 140')">bpm 140</button>
                <button class="quick-btn" onclick="sendCommand('clear')">clear all</button>
            </div>
        </div>
    </div>
    
    <!-- Visualizer Panel (Hidden by default) -->
    <div class="visualizer-panel" id="visualizerPanel">
        <div class="visualizer-header">
            <div class="visualizer-title">Visualiseur 8 Channels</div>
        </div>
        <div class="visualizer-content" id="visualizerContent">
            <!-- Les 8 channels seront cr√©√©es dynamiquement -->
        </div>
    </div>

    <script>
        let port = null;
        let reader = null;
        let writer = null;
        let isConnected = false;
        let linesState = {}; // Track state of each line { lineNumber: { content: '', sent: false, error: false } }
        let currentLineCount = 0;
        let autoScrollEnabled = true; // Auto-scroll activ√© par d√©faut

        // Check if user is scrolled to bottom
        function isScrolledToBottom() {
            const output = document.getElementById('consoleOutput');
            const threshold = 50; // 50px de marge
            return output.scrollHeight - output.scrollTop - output.clientHeight < threshold;
        }

        // Auto-scroll console (seulement si d√©j√† en bas)
        function scrollConsole() {
            if (autoScrollEnabled) {
                const output = document.getElementById('consoleOutput');
                output.scrollTop = output.scrollHeight;
            }
        }

        // Scroll to bottom (manual action)
        function scrollToBottom() {
            const output = document.getElementById('consoleOutput');
            output.scrollTop = output.scrollHeight;
            autoScrollEnabled = true;
            updateScrollButton();
        }

        // Update scroll button visibility
        function updateScrollButton() {
            const btn = document.getElementById('scrollToBottomBtn');
            if (!autoScrollEnabled && !isScrolledToBottom()) {
                btn.classList.add('visible');
            } else {
                btn.classList.remove('visible');
            }
        }

        // Add line to console
        function addConsoleLine(text, type = '') {
            const output = document.getElementById('consoleOutput');
            const line = document.createElement('div');
            line.className = 'console-line ' + type;
            line.textContent = text;
            output.appendChild(line);
            
            // Auto-scroll seulement si l'utilisateur √©tait d√©j√† en bas
            if (isScrolledToBottom()) {
                scrollConsole();
            }
            
            // Update scroll button visibility
            updateScrollButton();
        }

        // Clear console
        function clearConsole() {
            const output = document.getElementById('consoleOutput');
            output.innerHTML = '<div class="console-line info">Console cleared</div>';
            scrollConsole();
            updateScrollButton();
        }
        
        // ============================================================
        // VISUALIZER FUNCTIONS
        // ============================================================
        
        let visualizerVisible = false;
        let channelsData = {}; // Stocke les patterns pour chaque channel
        let playheadPosition = 0; // Position du playhead (0-100%)
        let animationFrameId = null;
        let currentBPM = 120; // BPM par d√©faut
        let lastFrameTime = 0; // Pour calculer deltaTime
        
        // Initialize visualizer
        function initVisualizer() {
            const content = document.getElementById('visualizerContent');
            content.innerHTML = '';
            
            // Cr√©er les 8 channels
            for (let i = 1; i <= 8; i++) {
                const channelRow = document.createElement('div');
                channelRow.className = 'channel-row';
                channelRow.innerHTML = `
                    <div class="channel-label">d${i}</div>
                    <div class="channel-timeline" id="timeline${i}">
                        <div class="playhead" id="playhead${i}"></div>
                        <div class="timeline-pattern" id="pattern${i}">~</div>
                    </div>
                `;
                content.appendChild(channelRow);
                
                // Initialiser les donn√©es du channel
                channelsData[`d${i}`] = {
                    pattern: '~',
                    events: [],
                    lastUpdate: 0
                };
            }
        }
        
        // Toggle visualizer
        function toggleVisualizer() {
            visualizerVisible = !visualizerVisible;
            const panel = document.getElementById('visualizerPanel');
            const btn = document.getElementById('visualizerToggle');
            
            if (visualizerVisible) {
                panel.classList.add('visible');
                btn.textContent = 'üìä Masquer Visualiseur';
                if (Object.keys(channelsData).length === 0) {
                    initVisualizer();
                }
                updateBPMDisplay();
                startVisualizerAnimation();
            } else {
                panel.classList.remove('visible');
                btn.textContent = 'üìä Afficher Visualiseur';
                stopVisualizerAnimation();
            }
        }
        
        // Update channel pattern
        function updateChannelPattern(channel, pattern) {
            if (!channelsData[channel]) return;
            
            channelsData[channel].pattern = pattern;
            channelsData[channel].lastUpdate = Date.now();
            
            // Parse le pattern pour cr√©er les event markers
            const events = parsePatternForVisualization(pattern);
            channelsData[channel].events = events;
            
            // Mettre √† jour l'affichage
            renderChannel(channel);
        }
        
        // Update BPM and refresh visualizer speed
        function updateBPM(newBPM) {
            if (newBPM && newBPM > 0 && newBPM <= 300) {
                currentBPM = newBPM;
                updateBPMDisplay();
                addConsoleLine(`‚ô™ BPM mis √† jour: ${currentBPM}`, 'info');
            }
        }
        
        // Update BPM display in visualizer header
        function updateBPMDisplay() {
            const title = document.querySelector('.visualizer-title');
            if (title) {
                title.textContent = `üéº Visualiseur 8 Channels | ${currentBPM} BPM`;
            }
        }
        
        // Parse pattern pour extraire les √©v√©nements et dur√©es
        // Supporte les multiplicateurs sous la forme `token*4` qui r√©p√®te le token
        function parsePatternForVisualization(pattern) {
            if (!pattern || pattern.trim() === '~') {
                return [];
            }

            // S√©parer les √©l√©ments du pattern
            const tokens = pattern.trim().split(/\s+/);
            const sequence = [];

            // Expander les multiplicateurs (e.g., hh*4 -> hh,hh,hh,hh)
            tokens.forEach(tok => {
                if (!tok || tok === '~') return;
                const m = tok.match(/^(.*)\*(\d+)$/);
                if (m) {
                    const label = m[1];
                    const count = Math.max(1, parseInt(m[2], 10) || 1);
                    for (let i = 0; i < count; i++) sequence.push(label);
                } else {
                    sequence.push(tok);
                }
            });

            if (sequence.length === 0) return [];

            const total = sequence.length;
            const events = sequence.map((label, idx) => {
                const start = (idx / total) * 100;
                const width = (1 / total) * 100;
                return {
                    start: start,
                    width: width,
                    label: label,
                    active: false,
                };
            });

            return events;
        }
        
        // Render un channel (dessine des bo√Ætes pour chaque √©v√©nement)
        function renderChannel(channel) {
            const channelNum = channel.replace('d', '');
            const timeline = document.getElementById(`timeline${channelNum}`);
            const patternDiv = document.getElementById(`pattern${channelNum}`);

            if (!timeline || !patternDiv) return;

            const data = channelsData[channel];

            // Afficher le pattern texte
            patternDiv.textContent = data.pattern || '~';

            // Effacer les anciennes boxes (mais pas le playhead ni le pattern text)
            const oldBoxes = timeline.querySelectorAll('.event-box');
            oldBoxes.forEach(b => b.remove());

            // Cr√©er les nouveaux boxes (ins√©rer avant le playhead pour le z-index)
            const playhead = timeline.querySelector('.playhead');
            data.events.forEach((event, idx) => {
                const box = document.createElement('div');
                box.className = 'event-box';
                box.style.left = event.start + '%';
                box.style.width = event.width + '%';
                box.setAttribute('data-index', idx);
                box.setAttribute('data-label', event.label);
                box.title = event.label;
                if (event.active) box.classList.add('active');
                // Ins√©rer avant le playhead pour garder le z-index correct
                if (playhead) {
                    timeline.insertBefore(box, playhead);
                } else {
                    timeline.appendChild(box);
                }
            });
        }
        
        // Animation du playhead (synchronis√© avec BPM)
        function animatePlayhead(timestamp) {
            if (!visualizerVisible) return;

            // Initialiser le temps de la premi√®re frame
            if (lastFrameTime === 0) {
                lastFrameTime = timestamp;
                animationFrameId = requestAnimationFrame(animatePlayhead);
                return; // Skip first frame to establish baseline
            }
            
            // Calculer le temps √©coul√© en millisecondes
            const deltaTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;

            // Calculer l'incr√©ment bas√© sur le BPM
            // Un cycle = 1 mesure √† 4 temps (4 beats)
            // Dur√©e d'une mesure en ms = (60000 / BPM) * 4
            const measureDurationMs = (60000 / currentBPM) * 4;
            
            // Incr√©menter la position en fonction du temps √©coul√©
            const increment = (deltaTime / measureDurationMs) * 100;
            playheadPosition += increment;
            
            // Boucler exactement √† 100%
            if (playheadPosition >= 100) {
                playheadPosition = playheadPosition % 100; // Modulo pour √©viter les d√©calages
            }

            // Mettre √† jour tous les playheads et √©tats actifs
            for (let i = 1; i <= 8; i++) {
                const playhead = document.getElementById(`playhead${i}`);
                const channelKey = `d${i}`;
                if (playhead) {
                    playhead.style.left = playheadPosition + '%';
                }

                // Update active box per channel
                const data = channelsData[channelKey];
                if (!data || !data.events) continue;

                data.events.forEach((ev, idx) => {
                    const wasActive = ev.active;
                    const inRange = (playheadPosition >= ev.start) && (playheadPosition < (ev.start + ev.width));
                    ev.active = inRange;
                    if (wasActive !== ev.active) {
                        // Update DOM box
                        const timeline = document.getElementById(`timeline${i}`);
                        if (!timeline) return;
                        const box = timeline.querySelector(`.event-box[data-index='${idx}']`);
                        if (box) {
                            if (ev.active) box.classList.add('active');
                            else box.classList.remove('active');
                        }
                    }
                });
            }

            animationFrameId = requestAnimationFrame(animatePlayhead);
        }
        
        // Start animation
        function startVisualizerAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            playheadPosition = 0;
            lastFrameTime = 0; // Reset timer
            // D√©marrer avec requestAnimationFrame pour avoir le timestamp
            animationFrameId = requestAnimationFrame(animatePlayhead);
        }
        
        // Stop animation
        function stopVisualizerAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        // ============================================================
        // END VISUALIZER FUNCTIONS
        // ============================================================

        // Update connection status
        function updateStatus(connected) {
            isConnected = connected;
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connect√©';
                document.getElementById('connectionModal').classList.add('hidden');
                document.getElementById('codeEditor').focus();
            } else {
                statusDot.classList.remove('connected');
                statusText.textContent = 'D√©connect√©';
            }
        }

        // Update line numbers display
        function updateLineNumbers() {
            const editor = document.getElementById('codeEditor');
            const lineNumbers = document.getElementById('lineNumbers');
            const lines = editor.value.split('\n');
            const lineCount = lines.length;
            
            // Get cursor position to highlight current line
            const cursorPos = editor.selectionStart;
            const textBeforeCursor = editor.value.substring(0, cursorPos);
            const currentLine = textBeforeCursor.split('\n').length;
            
            let html = '';
            for (let i = 1; i <= lineCount; i++) {
                let className = '';
                if (i === currentLine) className = 'active';
                else if (linesState[i] && linesState[i].modified) className = 'modified';
                else if (linesState[i] && linesState[i].error) className = 'error';
                
                html += `<div class="${className}">${i}</div>`;
            }
            lineNumbers.innerHTML = html;
            currentLineCount = lineCount;
            
            // Sync scroll
            lineNumbers.scrollTop = editor.scrollTop;
        }

        // Parse a single line for errors (basic validation)
        function parseLine(line) {
            line = line.trim();
            
            // Empty lines and comments are OK
            if (line === '' || line.startsWith('--')) {
                return { valid: true, type: 'comment' };
            }
            
            // Check for channel patterns (d1-d8)
            if (/^d[1-8]\s+/.test(line)) {
                return { valid: true, type: 'pattern' };
            }
            
            // Check for commands
            if (/^(bpm|clear|hush|silence|help)\b/.test(line)) {
                return { valid: true, type: 'command' };
            }
            
            return { valid: false, type: 'unknown', error: 'Syntax non reconnue' };
        }

        // Real-time parsing on editor change
        function onEditorChange() {
            updateLineNumbers();
            
            const editor = document.getElementById('codeEditor');
            const lines = editor.value.split('\n');
            
            // Parse each line and update state
            lines.forEach((line, index) => {
                const lineNum = index + 1;
                const parsed = parseLine(line);
                
                if (!linesState[lineNum]) {
                    linesState[lineNum] = {};
                }
                
                // Check if line was modified
                if (linesState[lineNum].content !== line) {
                    linesState[lineNum].modified = true;
                    linesState[lineNum].sent = false;
                }
                
                linesState[lineNum].content = line;
                linesState[lineNum].error = !parsed.valid;
                linesState[lineNum].type = parsed.type;
            });
        }

        // Send command to Teensy
        async function sendCommand(command) {
            if (!isConnected || !writer) {
                addConsoleLine('‚úó Non connect√©', 'error');
                return false;
            }

            try {
                await writer.write(command + '\n');
                return true;
            } catch (error) {
                addConsoleLine('‚úó Erreur d\'envoi: ' + error.message, 'error');
                console.error('Send error:', error);
                return false;
            }
        }

        // Evaluate all code
        async function evaluateCode() {
            if (!isConnected) {
                addConsoleLine('‚úó Non connect√© au Teensy', 'error');
                return;
            }
            
            const editor = document.getElementById('codeEditor');
            const lines = editor.value.split('\n');
            
            addConsoleLine('‚ñ∂ √âvaluation de tout le code...', 'info');
            
            let sentCount = 0;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const lineNum = i + 1;
                
                // Skip empty lines and comments
                if (line === '' || line.startsWith('--')) {
                    continue;
                }
                
                // Parse and validate
                const parsed = parseLine(line);
                if (!parsed.valid) {
                    addConsoleLine(`Line ${lineNum}: ${parsed.error}`, 'error');
                    linesState[lineNum].error = true;
                    continue;
                }
                
                // Send to Teensy
                addConsoleLine(`‚Üí ${line}`, 'prompt');
                const success = await sendCommand(line);
                
                if (success) {
                    linesState[lineNum].sent = true;
                    linesState[lineNum].modified = false;
                    linesState[lineNum].error = false;
                    sentCount++;
                    
                    // Update visualizer if it's a pattern command
                    if (/^d[1-8]\s+/.test(line)) {
                        const match = line.match(/^(d[1-8])\s+(.+)$/);
                        if (match) {
                            updateChannelPattern(match[1], match[2]);
                        }
                    }
                    
                    // Update BPM if it's a BPM command
                    if (/^bpm\s+\d+/.test(line)) {
                        const bpmMatch = line.match(/^bpm\s+(\d+)/);
                        if (bpmMatch) {
                            updateBPM(parseInt(bpmMatch[1], 10));
                        }
                    }
                }
                
                // Small delay between commands
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            addConsoleLine(`‚úì ${sentCount} commande(s) envoy√©e(s)`, 'success');
            updateLineNumbers();
        }

        // Evaluate current line or selection
        async function evaluateSelection() {
            if (!isConnected) {
                addConsoleLine('‚úó Non connect√© au Teensy', 'error');
                return;
            }
            
            const editor = document.getElementById('codeEditor');
            const cursorPos = editor.selectionStart;
            const textBeforeCursor = editor.value.substring(0, cursorPos);
            const currentLineNum = textBeforeCursor.split('\n').length;
            
            const lines = editor.value.split('\n');
            const line = lines[currentLineNum - 1].trim();
            
            if (line === '' || line.startsWith('--')) {
                addConsoleLine('Line vide ou commentaire, ignor√©', 'info');
                return;
            }
            
            // Parse and validate
            const parsed = parseLine(line);
            if (!parsed.valid) {
                addConsoleLine(`Erreur ligne ${currentLineNum}: ${parsed.error}`, 'error');
                linesState[currentLineNum].error = true;
                updateLineNumbers();
                return;
            }
            
            // Send to Teensy
            addConsoleLine(`‚Üí Line ${currentLineNum}: ${line}`, 'prompt');
            const success = await sendCommand(line);
            
            if (success) {
                linesState[currentLineNum].sent = true;
                linesState[currentLineNum].modified = false;
                linesState[currentLineNum].error = false;
                updateLineNumbers();
                
                // Update visualizer if it's a pattern command
                if (/^d[1-8]\s+/.test(line)) {
                    const match = line.match(/^(d[1-8])\s+(.+)$/);
                    if (match) {
                        updateChannelPattern(match[1], match[2]);
                    }
                }
                
                // Update BPM if it's a BPM command
                if (/^bpm\s+\d+/.test(line)) {
                    const bpmMatch = line.match(/^bpm\s+(\d+)/);
                    if (bpmMatch) {
                        updateBPM(parseInt(bpmMatch[1], 10));
                    }
                }
            }
        }

        // Clear all patterns (send silence to all channels)
        async function clearAllPatterns() {
            if (!isConnected) {
                addConsoleLine('‚úó Non connect√© au Teensy', 'error');
                return;
            }
            
            addConsoleLine('‚ñ† Arr√™t de tous les patterns...', 'info');
            await sendCommand('clear');
            
            // Clear visualizer
            for (let i = 1; i <= 8; i++) {
                updateChannelPattern(`d${i}`, '~');
            }
            addConsoleLine('‚úì Tous les patterns arr√™t√©s', 'success');
        }

        // Insert code at cursor position
        function insertCode(code) {
            const editor = document.getElementById('codeEditor');
            const cursorPos = editor.selectionStart;
            const textBefore = editor.value.substring(0, cursorPos);
            const textAfter = editor.value.substring(cursorPos);
            
            // Insert at cursor position
            editor.value = textBefore + code + '\n' + textAfter;
            
            // Move cursor to end of inserted code
            const newCursorPos = cursorPos + code.length + 1;
            editor.setSelectionRange(newCursorPos, newCursorPos);
            editor.focus();
            
            onEditorChange();
        }

        // Connect to serial port
        async function connectSerial() {
            if (!('serial' in navigator)) {
                addConsoleLine('‚úó Web Serial API non support√©e', 'error');
                addConsoleLine('Utilisez Chrome, Edge ou Opera', 'error');
                return;
            }

            try {
                addConsoleLine('S√©lection du port s√©rie...', 'info');
                
                port = await navigator.serial.requestPort({
                    filters: [
                        { usbVendorId: 0x16C0 }, // Teensy
                        { usbVendorId: 0x2341 }, // Arduino
                    ]
                });
                
                addConsoleLine('Ouverture du port...', 'info');
                
                await port.open({ 
                    baudRate: 115200,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none'
                });

                addConsoleLine('‚úì Connect√© au Teensy!', 'success');
                
                // Setup reader
                const textDecoder = new TextDecoderStream();
                const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
                reader = textDecoder.readable.getReader();

                // Setup writer
                const textEncoder = new TextEncoderStream();
                const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
                writer = textEncoder.writable.getWriter();

                updateStatus(true);
                readLoop();

            } catch (error) {
                addConsoleLine('‚úó Erreur de connexion: ' + error.message, 'error');
                
                if (error.name === 'NotFoundError') {
                    addConsoleLine('Aucun port s√©lectionn√©', 'error');
                } else if (error.name === 'InvalidStateError') {
                    addConsoleLine('Le port est d√©j√† ouvert', 'error');
                }
                
                console.error('Connection error:', error);
            }
        }

        // Read loop
        async function readLoop() {
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        addConsoleLine('‚úó Connexion ferm√©e', 'error');
                        updateStatus(false);
                        break;
                    }
                    if (value) {
                        const lines = value.split('\n');
                        lines.forEach(line => {
                            const trimmed = line.trim();
                            if (trimmed) {
                                addConsoleLine(trimmed, 'teensy');
                            }
                        });
                    }
                }
            } catch (error) {
                addConsoleLine('‚úó Erreur de lecture: ' + error.message, 'error');
                console.error('Read error:', error);
                updateStatus(false);
            }
        }

        // Disconnect
        async function toggleConnection() {
            if (!isConnected) {
                connectSerial();
                return;
            }

            try {
                if (reader) {
                    await reader.cancel();
                    reader = null;
                }
                if (writer) {
                    await writer.close();
                    writer = null;
                }
                if (port) {
                    await port.close();
                    port = null;
                }
                
                addConsoleLine('‚úì D√©connect√©', 'info');
                updateStatus(false);
            } catch (error) {
                addConsoleLine('‚úó Erreur lors de la d√©connexion: ' + error.message, 'error');
                console.error('Disconnect error:', error);
            }
        }

        // Editor event listeners
        document.getElementById('codeEditor').addEventListener('input', onEditorChange);
        document.getElementById('codeEditor').addEventListener('scroll', function() {
            document.getElementById('lineNumbers').scrollTop = this.scrollTop;
        });
        document.getElementById('codeEditor').addEventListener('click', updateLineNumbers);
        document.getElementById('codeEditor').addEventListener('keyup', updateLineNumbers);

        // Console scroll listener - detect if user scrolls up
        document.getElementById('consoleOutput').addEventListener('scroll', function() {
            // Si l'utilisateur est en bas, r√©activer l'auto-scroll
            if (isScrolledToBottom()) {
                autoScrollEnabled = true;
            } else {
                // Si l'utilisateur remonte, d√©sactiver temporairement l'auto-scroll
                autoScrollEnabled = false;
            }
            updateScrollButton();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Ctrl+Enter : Evaluate all code
            if (event.ctrlKey && event.key === 'Enter') {
                evaluateCode();
                event.preventDefault();
            }
            
            // Shift+Enter : Evaluate current line
            if (event.shiftKey && event.key === 'Enter') {
                evaluateSelection();
                event.preventDefault();
            }
            
            // Ctrl+. : Stop all patterns
            if (event.ctrlKey && event.key === '.') {
                clearAllPatterns();
                event.preventDefault();
            }
            
            // Ctrl+L : Clear console
            if (event.ctrlKey && event.key === 'l') {
                clearConsole();
                event.preventDefault();
            }
        });

        // Check for Web Serial API support
        window.addEventListener('load', function() {
            if (!('serial' in navigator)) {
                addConsoleLine('‚úó Web Serial API non support√©e dans ce navigateur', 'error');
                addConsoleLine('Veuillez utiliser Chrome, Edge ou Opera', 'error');
            } else {
                addConsoleLine('‚úì Web Serial API disponible', 'success');
                addConsoleLine('Cliquez sur le bouton de connexion pour commencer', 'info');
                addConsoleLine('', '');
                addConsoleLine('Raccourcis clavier:', 'info');
                addConsoleLine('  Ctrl+Enter : √âvaluer tout le code', 'info');
                addConsoleLine('  Shift+Enter : √âvaluer la ligne courante', 'info');
                addConsoleLine('  Ctrl+. : Arr√™ter tous les patterns', 'info');
                addConsoleLine('  Ctrl+L : Effacer la console', 'info');
            }
            
            updateLineNumbers();
            updateScrollButton();
        });

        // Test function for scroll (accessible from browser console)
        // Usage: testScroll()
        function testScroll() {
            for (let i = 0; i < 50; i++) {
                addConsoleLine(`Test line ${i + 1} - Lorem ipsum dolor sit amet`, 'info');
            }
        }
    </script>
</body>
</html>
